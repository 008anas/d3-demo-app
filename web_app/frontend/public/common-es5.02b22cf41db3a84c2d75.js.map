{"version":3,"sources":["webpack:///src/app/shared/utils.ts","webpack:///src/app/shared/directives/copy-clipboard.directive.ts","webpack:///src/app/shared/components/text-modal/text-modal.component.html","webpack:///src/app/shared/components/text-modal/text-modal.component.ts","webpack:///src/app/workspace/shared/user-history.ts"],"names":["Utils","StringUtil","line","padString","length","str","main_seq","seq","indexOf","arr","old_index","new_index","k","push","splice","serSeq","options","reformatSeqName","isProtein","type","sequence","proteinSequence","lines","createGenbankLocus","definition","description","extraLines","concat","comments","forEach","comment","teselagen_unique_id","library","e","console","warn","stack","val","start","end","slice","join","dnaType","symbols","split","date","getCurrentDateString","nameToUse","name","toString","replace","String","circular","gbDivision","feat","locStr","locations","loc","i","getProteinStart","parseInt","inclusive1BasedStart","getProteinEnd","inclusive1BasedEnd","strand","featureNoteInDataToGenbankString","notes","JSON","parse","Object","keys","key","Array","value","color","labelColor","Date","toUpperCase","Math","floor","data","fastaString","c","log","match","dnaSeqRegex","porteinSeqRegex","urlRegex","CopyClipboardDirective","copied","event","preventDefault","this","payload","listener","clipboardData","window","setData","emit","document","addEventListener","execCommand","removeEventListener","TextModalComponent","txt","copy","UserHistory","job","status","isActive","isDone"],"mappings":"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","file":"x","sourcesContent":["const nameUtils = {\n\t/**\n\t * Reformat name to replaces whitespace with underscores.\n\t * @returns {String} New name.\n\t */\n  reformatName: (pName: string): string => pName.toString().replace(/ /g, '_'),\n};\nconst StringUtil = {\n  /** Trims white space at beginning and end of string\n   * @returns {String} line\n   */\n  trim: (line: string): string => line.replace(/^\\s+|\\s+$/g, ''),\n\n  /** Trims white space at beginning string\n   * @returns {String} line\n   */\n  ltrim: (line: string): string => line.replace(/^\\s+/, ''),\n\n  /** Trims white space at end of string\n   * @returns {String} line\n   */\n  rtrim: (line: string): string => line.replace(/\\s+$/, ''),\n\n  /** Pads white space at beginning of string\n   * @returns {String} line\n   */\n  lpad: (line: string, padString, length): string => {\n    let str = line;\n    while (str.length < length) str = padString + str;\n    return str;\n  },\n\n  /** Pads white space at end of string\n   * @param {String} line\n   * @returns {String} line\n   */\n  rpad: (line: string, padString, length): string => {\n    let str = line;\n    while (str.length < length) str = str + padString;\n    return str;\n  }\n};\n\nexport default class Utils {\n\n  static dnaSeqRegex = /^[CAGTNU\\n]+$/i;\n  static porteinSeqRegex = /^[ARNDCQEGHILKMFPSTWYVX*]+$/i;\n  static urlRegex = /^(?:(?:https?|ftp):\\/\\/)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:\\/\\S*)?$/;\n\n  static array_move(arr: any[], old_index: number, new_index: number) {\n    if (new_index >= arr.length) {\n      let k = new_index - arr.length + 1;\n      while (k--) {\n        arr.push(undefined);\n      }\n    }\n    arr.splice(new_index, 0, arr.splice(old_index, 1)[0]);\n    return arr;\n  }\n\n  static jsonToGenbank(serSeq, options?) {\n    options = options || {};\n    options.reformatSeqName = options.reformatSeqName !== false;\n\n    if (!serSeq) { return false; }\n\n    try {\n      if (serSeq.isProtein || serSeq.type === 'protein' || serSeq.type === 'AA') {\n        serSeq.isProtein = true;\n        serSeq.sequence = serSeq.proteinSequence || serSeq.sequence;\n        options.isProtein = true;\n      }\n      const content = null;\n      const cutUp = typeof serSeq.sequence === 'string' ? Utils.cutUpStr : Utils.cutUpArray;\n      if (!serSeq.sequence) { serSeq.sequence = ''; }\n\n      let lines = [];\n      lines.push(Utils.createGenbankLocus(serSeq, options));\n      if (serSeq.definition || serSeq.description) {\n        lines.push('DEFINITION  ' + (serSeq.definition || serSeq.description));\n      }\n\n      if (serSeq.extraLines) {\n        lines = lines.concat(serSeq.extraLines);\n      }\n      if (serSeq.comments) {\n        serSeq.comments.forEach((comment: string) => lines.push('COMMENT             ' + comment));\n      }\n      if (serSeq.teselagen_unique_id) {\n        lines.push(\n          'COMMENT             teselagen_unique_id: ' + serSeq.teselagen_unique_id\n        );\n      }\n      if (serSeq.library) {\n        lines.push('COMMENT             library: ' + serSeq.library);\n      }\n\n      return content;\n\n      // serSeq.features = serSeq.features.map().concat(\n      //   flatMap(pragmasAndTypes, ({ pragma, type }) => {\n      //     return flatMap(serSeq[type], ann => {\n      //       if (!isObject(ann)) {\n      //         return [];\n      //       }\n      //       ann.notes = pragma\n      //         ? {\n      //           ...ann.notes,\n      //           pragma: [pragma]\n      //         }\n      //         : ann.notes;\n      //       return ann;\n      //     });\n      //   })\n      // );\n      //\n      // let printedFeatureHeader;\n      // serSeq.features.foreach((feat, index) => {\n      //   if (!printedFeatureHeader) {\n      //     printedFeatureHeader = true;\n      //     lines.push('FEATURES             Location/Qualifiers');\n      //   }\n      //   lines.push(Utils.featureToGenbankString(feat, options));\n      // });\n      //\n      // lines.push('ORIGIN      ');\n      // for (let i = 0; i < serSeq.sequence.length; i = i + 60) {\n      //   const line = [];\n      //   const ind = StringUtil.lpad('' + (i + 1), ' ', 9);\n      //   line.push(ind);\n      //\n      //   for (let j = i; j < i + 60; j = j + 10) {\n      //     // line.push(serSeq.sequence.slice(j,j+10).join(''));\n      //     line.push(cutUp(serSeq.sequence, j, j + 10));\n      //   }\n      //   lines.push(line.join(' '));\n      // }\n      //\n      // lines.push('//');\n      //\n      // content = lines.join('\\r\\n');\n      // // return cb(err, content);\n      // return content;\n    } catch (e) {\n      console.warn('Error processing sequence << Check jsonToGenbank.js');\n      console.warn(serSeq);\n      console.warn(e.stack);\n      return false;\n    }\n  }\n\n  static cutUpArray(val, start, end) {\n    return val.slice(start, end).join('');\n  }\n\n  static cutUpStr(val, start, end) {\n    return val.slice(start, end);\n  }\n\n  static createGenbankLocus(serSeq, options) {\n    if (serSeq.sequence.symbols) {\n      serSeq.sequence = serSeq.sequence.symbols.split('');\n    }\n\n    let tmp;\n    let dnaType;\n    if (serSeq.isProtein) {\n      dnaType = '';\n    } else if (serSeq.type === 'RNA') {\n      dnaType = 'RNA';\n    } else {\n      dnaType = 'DNA';\n    }\n    const date = Utils.getCurrentDateString();\n\n    let line = StringUtil.rpad('LOCUS', ' ', 12);\n    let nameToUse = serSeq.name || 'Untitled_Sequence';\n    nameToUse = options.reformatSeqName\n      ? nameUtils.reformatName(nameToUse)\n      : nameToUse;\n    line += StringUtil.rpad(nameToUse, ' ', 16);\n    line += ' '; // T.H line 2778 of GenbankFormat.as col 29 space\n    line += StringUtil.lpad(String(serSeq.sequence.length), ' ', 11);\n    line += serSeq.isProtein ? ' aa ' : ' bp '; // col 41\n    // if (strandType !== '') {\n    // \ttmp =  strandType + '-';\n    // } else {\n    tmp = '';\n    // }\n    line += StringUtil.lpad(tmp, ' ', 3);\n    line += StringUtil.rpad(dnaType, ' ', 6);\n    line += '  ';\n\n    if (!serSeq.circular || serSeq.circular === '0') {\n      line += 'linear  ';\n      // line += '        ';\n    } else {\n      line += 'circular';\n    }\n\n    line += ' '; // col 64\n    if (serSeq.gbDivision) {\n      line += StringUtil.rpad(serSeq.gbDivision || 'SYN', ' ', 10);\n    }\n    // }\n    line += ' '; // col 68\n    // DOES NOT PARSE DATE USEFULLY ORIGINALLY!\n    line += date;\n    // line += '\\n';\n\n    return line;\n  }\n\n  static featureToGenbankString(feat, options) {\n    const lines = [];\n\n    const line = '     ' + StringUtil.rpad(feat.type || 'misc_feature', ' ', 16);\n    let locStr = '';\n\n    // for(var i=0;i<feat.locations.length;i++) {\n    //\tvar loc = feat.locations[i];\n    //\tlocStr.push((loc.start+1) + '..' + loc.end);\n    // }\n\n    if (feat.locations && feat.locations.length > 1) {\n      feat.locations.forEach((loc, i) => {\n        locStr +=\n          Utils.getProteinStart(\n            parseInt(loc.start, 10) + (options.inclusive1BasedStart ? 0 : 1),\n            options.isProtein\n          ) +\n          '..' +\n          Utils.getProteinEnd(\n            parseInt(loc.end, 10) + (options.inclusive1BasedEnd ? 0 : 1),\n            options.isProtein\n          );\n\n        if (i !== feat.locations.length - 1) {\n          locStr += ',';\n        }\n      });\n      locStr = 'join(' + locStr + ')';\n    } else {\n      locStr +=\n        Utils.getProteinStart(\n          parseInt(feat.start, 10) + (options.inclusive1BasedStart ? 0 : 1),\n          options.isProtein\n        ) +\n        '..' +\n        Utils.getProteinEnd(\n          parseInt(feat.end, 10) + (options.inclusive1BasedEnd ? 0 : 1),\n          options.isProtein\n        );\n    }\n\n    // locStr = locStr.join(',');\n\n    if (feat.strand === -1) {\n      locStr = 'complement(' + locStr + ')';\n    }\n\n    lines.push(line + locStr);\n\n    lines.push(\n      Utils.featureNoteInDataToGenbankString('label', feat.name || 'Untitled Feature')\n    );\n\n    let notes = feat.notes;\n    if (notes) {\n      try {\n        if (typeof notes === 'string') {\n          try {\n            notes = JSON.parse(notes);\n          } catch (e) {\n            console.warn('Warning: Note incorrectly sent as a string.');\n            notes = {}; // set the notes to a blank object\n          }\n        }\n        Object.keys(notes).forEach((key) => {\n          if (key === 'color' || key === 'labelColor') { return; } //we'll handle this below\n          if (notes[key] instanceof Array) {\n            notes[key].forEach((value) => lines.push(Utils.featureNoteInDataToGenbankString(key, value)));\n          } else {\n            console.warn('Warning: Note object expected array values');\n            console.warn(notes);\n          }\n        });\n      } catch (e) {\n        console.warn('Warning: Note cannot be processed');\n      }\n    }\n    feat.color = (feat.notes && feat.notes.color) || feat.color;\n    feat.labelColor = (feat.notes && feat.notes.labelColor) || feat.labelColor;\n\n    // if (\n    //   feat.color &&\n    //   color.rgb(feat.color).string() !==\n    //   color.rgb(featureColors[feat.type]).string() //don't save a color note if the color is already the same as our defaults\n    // ) {\n    //   lines.push(Utils.featureNoteInDataToGenbankString('color', feat.color));\n    // }\n    if (feat.labelColor) {\n      lines.push(Utils.featureNoteInDataToGenbankString('labelColor', feat.labelColor));\n    }\n\n    return lines.join('\\r\\n');\n  }\n\n  static getCurrentDateString() {\n    const date = new Date();\n    // date = date.toString().split(' ');\n    const day = date[2];\n    const month = date[1].toUpperCase();\n    const year = date[3];\n    return day + '-' + month + '-' + year;\n  }\n\n  static getProteinStart(val, isProtein) {\n    if (!isProtein) { return val; }\n    return Math.floor((val + 2) / 3);\n  }\n  static getProteinEnd(val, isProtein) {\n    if (!isProtein) { return val; }\n    return Math.floor(val / 3);\n  }\n\n  static featureNoteInDataToGenbankString(name, value) {\n    return StringUtil.lpad('/', ' ', 22) + name + '=\"' + value + '\"';\n  }\n\n  static jsonToFasta(data: any[]) {\n    if (!data) { return null; }\n\n    let fastaString = '';\n    data.forEach((c: any) => {\n      if (c.sequence) {\n        console.log(c.sequence);\n        fastaString += `>${c.name || 'Untitled Sequence'}`;\n        fastaString += `|${c.sequence.length}`;\n        fastaString += c.description ? '|' + c.description : '';\n        fastaString += '|' + (c.circular ? 'circular' : 'linear') || 'linear';\n        fastaString += '\\n';\n        fastaString += (c.sequence.match(/.{1,80}/g) || []).join('\\n');\n      }\n    });\n    return fastaString;\n  }\n\n  getPosFromSeq(main_seq: string, seq: string) {\n    if (!main_seq || seq || main_seq.length < seq.length) { return null; }\n    return main_seq.indexOf(seq);\n  }\n\n}\n","import { Directive, Input, Output, EventEmitter, HostListener } from '@angular/core';\n\n@Directive({\n  selector: '[copy-clipboard]'\n})\nexport class CopyClipboardDirective {\n\n  @Input('copy-clipboard')\n  public payload: string;\n\n  @Input()\n  public context: string;\n\n  @Output()\n  public copied: EventEmitter<string> = new EventEmitter<string>();\n\n  @HostListener('click', ['$event'])\n  public onClick(event: MouseEvent): void {\n    event.preventDefault();\n    if (!this.payload) { return; }\n\n    const listener = (e: ClipboardEvent) => {\n      const clipboard = e.clipboardData || window['clipboardData'];\n      clipboard.setData('text', this.payload.toString());\n      e.preventDefault();\n      this.copied.emit(this.payload);\n    };\n\n    document.addEventListener('copy', listener, false);\n    document.execCommand('copy');\n    document.removeEventListener('copy', listener, false);\n  }\n\n}\n","<!-- Sequence modal-->\n<div class=\"ui padded grid\">\n\n  <div class=\"one column row\">\n    <div class=\"column\">\n      <strong> {{description | titlecase}} Length:</strong>{{txt?.length}}\n    </div>\n    <div class=\"column txt-r\" *ngIf=\"copy\">\n      <button class=\"ui compact right labeled icon primary button\" [copy-clipboard]=\"txt\">\n        <i class=\"copy icon\"></i>\n        Copy\n      </button>\n    </div>\n  </div>\n\n  <div class=\"row\">\n    <div class=\"column\">\n      <p>{{txt}}</p>\n    </div>\n  </div>\n\n</div>\n","import { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'sqy-text-modal',\n  templateUrl: './text-modal.component.html',\n  styleUrls: ['./text-modal.component.scss']\n})\nexport class TextModalComponent {\n\n  @Input() txt: string = null;\n  @Input() description: string = null;\n  @Input() copy = true;\n\n}\n","import { Deserializable } from '@models/deserializable.model';\nimport { Job } from './job';\nimport { Construct } from '@models/construct';\n\nexport class UserHistory extends Deserializable {\n  id: string;\n  name: string;\n  slug: string;\n  construct: Construct;\n  job_id: string;\n  job: Job;\n  created_at: string;\n  updated_at: string;\n\n  isDone() {\n    return this.job && this.job.status === 'finished';\n  }\n\n  isActive() {\n    return this.job && (this.job.status === 'queued' || this.job.status === 'started');\n  }\n\n  hasFailed() {\n    return !this.isActive() && !this.isDone();\n  }\n}\n"]}